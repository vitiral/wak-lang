WHITESPACE = _{ " " | "\t" | "\n" | "\r\n" }
COMMENT = _{ "//" ~ (!"\n" ~ ANY)* }

file = _{
  SOI
  ~ (expr ~ ";")*
  ~ EOI
}

expr = { 
  expr_item ~ (
    operation
    | expand1
    | expand2
  )?
}

expr_item = { value | closed | declare | iden | type_ | arbitrary }

////////////////
// Operation

operation = { operator ~ expr }

ACCESS      = { "." }
CALL        = { "$" }

operator = _{ ACCESS | CALL }

expand1 = { EXPAND1 ~ expr }
// Note: arbitrary not actually allowed in first item.
expand2 = { EXPAND2 ~ (expr_item | arbitrary) ~ expr }

EXPAND1     = _{ "!" }
EXPAND2     = _{ "!!" }

////////////////
// Keywords
LET = { "let" }
VISIBILITY = { "pub" }
OWNERSHIP = { "const" | "own" | "ref" | "excl" }
END = { ";" }

///////////////////
// Identifiers
iden = @{ (!(ASCII_DIGIT) ~ iden_char) ~ iden_char* }
iden_char = @{ "_" | ASCII_ALPHANUMERIC }

////////////////
// Value Literals
value = { bool | float | integer | raw_string | string | char }

bool = { "true" | "false" }

float = @{
  ("+"|"-")?
  ~ ASCII_DIGIT ~ DIGIT*
  ~ "." ~  DIGIT*
  ~ (^"e" ~ ("-"|"+")? ~ DIGIT+)?
}

integer = @{
  ("+" | "-")?
  ~ (
    "0x" ~ DIGIT_HEX+
    | ASCII_DIGIT ~ DIGIT*
  )
}

char = {
  "'" ~ !("'") ~ string_char ~ "'"
}

raw_string = ${
  "''" ~ PUSH("'"*) // push the number of `'` onto the stack
  ~ raw_string_inner
  ~ "''" ~ POP
}

raw_string_inner = @{ raw_string_char* }
raw_string_char = @{
  // Consume any character unless the next
  // characters are the correct number of single-quotes
  !("''" ~ PEEK) ~ ANY
}

string = ${
  "\"" ~ string_inner ~ "\""
}

string_inner = @{ string_char* }
string_char = @{
  !("\"" | "\\") ~ ANY
  | "\\" ~ ("\\" | "\"" | "b" | "f" | "n" | "r" | "t")
  | "\\" ~ ("u" ~ ASCII_HEX_DIGIT{4})
}

DIGIT = @{ASCII_DIGIT | "_"}
DIGIT_HEX = @{ASCII_HEX_DIGIT | "_"}

////////////////
// Declaration

declare = { declare_fn /*| declare_struct | declare_interface | declare_impl*/ | declare_var }
declare_fn = { VISIBILITY? ~ "fn" ~ iden ~ data ~ ("->" ~ data)? ~ block }
declare_var = { 
  LET ~ VISIBILITY? ~ iden ~ type_? ~ ("=" ~ expr)?
  | iden ~ type_? ~ "=" ~ expr
}

////////////////
// Closed Expressions

closed = { block | data }

block = { 
   "(" ~ (expr ~ END)* ~ (expr ~ END?)? ~ ")"
}

data = { "{" ~ (declare_var  ~ ";")* ~ (declare_var ~ ";"?)? ~ "}" }

// TODO: replace type_ with this
type_ = {  type_closed | type_inner }
type_closed = { "[" ~ declare_type* ~ type_inner ~ "]" }
type_inner = { iden ~ ("[" ~ type_inner ~ "]")? }
declare_type = { iden ~ "=" ~ expr ~ END }

arbitrary = { "(" ~ arbitrary_inner* ~ ")" }
arbitrary_inner = _{ value | arbitrary | arbitrary_token }
arbitrary_token = @{ 
  !("(" | ")") ~ ANY
}

